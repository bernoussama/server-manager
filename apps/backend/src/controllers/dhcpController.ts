import type { Response } from 'express';
import type { AuthRequest } from '../middlewares/authMiddleware';
import { dhcpConfigSchema, transformDhcpFormToApi, type DhcpConfigFormValues } from '@server-manager/shared/validators';
import type { DhcpConfiguration, DhcpServiceResponse, NetworkInterface, NetworkInterfaceResponse } from '@server-manager/shared';
import { ZodError } from 'zod';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { existsSync } from 'fs';
import crypto from 'crypto';
import fs from 'fs';
import logger from '../lib/logger.js';
import { ServiceManager } from '../lib/ServiceManager.js';
import { MockServiceManager } from '../lib/MockServiceManager.js';
import config from '../config/config.js';

const execAsync = promisify(exec);
const serviceManager = config.useMockServices ? new MockServiceManager() : new ServiceManager();

// Configuration paths
const isProd = process.env.NODE_ENV === 'production';
const DHCPD_CONF_DIR = isProd ? '/etc/dhcp' : './test/dhcp/config';
const DHCPD_CONF_PATH = isProd ? '/etc/dhcp/dhcpd.conf' : './test/dhcp/config/dhcpd.conf';
const DHCPD_BACKUP_DIR = isProd ? '/etc/dhcp/backups' : './test/dhcp/backups';
const DHCPD_LEASES_PATH = isProd ? '/var/lib/dhcpd/dhcpd.leases' : './test/dhcp/dhcpd.leases';

// Ensure directory exists
const ensureDirectoryExists = async (dir: string): Promise<void> => {
  try {
    if (!existsSync(dir)) {
      await mkdir(dir, { recursive: true });
      logger.info(`Created directory: ${dir}`);
    }
  } catch (error) {
    logger.error(`Failed to create directory ${dir}:`, error);
    throw new Error(`Failed to create directory: ${dir}`);
  }
};

// Check write permissions
const checkWritePermission = async (filePath: string): Promise<boolean> => {
  try {
    const dir = path.dirname(filePath);
    await fs.promises.access(dir, fs.constants.W_OK);
    return true;
  } catch (error) {
    logger.warn(`No write permission for ${filePath}`);
    return false;
  }
};

// Write file with backup functionality
const writeFileWithBackup = async (
  filePath: string, 
  content: string, 
  options?: {
    writeJsonVersion?: boolean;
    jsonContent?: string;
    jsonGenerator?: () => string;
  }
): Promise<void> => {
  const dir = path.dirname(filePath);
  const filename = path.basename(filePath);
  const backupDir = path.join(dir, 'backups');
  
  // Ensure directories exist
  await ensureDirectoryExists(dir);
  await ensureDirectoryExists(backupDir);
  
  // Check write permissions
  const canWrite = await checkWritePermission(filePath);
  if (!canWrite) {
    throw new Error(`No write permission for ${filePath}`);
  }
  
  // Create backup if file exists
  if (existsSync(filePath)) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFilePath = path.join(backupDir, `${filename}.${timestamp}.backup`);
    
    try {
      const existingContent = await readFile(filePath, 'utf8');
      await writeFile(backupFilePath, existingContent, 'utf8');
      logger.info(`Backup created: ${backupFilePath}`);
    } catch (error) {
      logger.warn(`Failed to create backup for ${filePath}:`, error);
    }
  }
  
  // Write the main file
  await writeFile(filePath, content, 'utf8');
  logger.info(`Configuration written to: ${filePath}`);
  
  // Write JSON version if requested
  if (options?.writeJsonVersion) {
    const jsonPath = `${filePath}.json`;
    let jsonContent = options.jsonContent;
    
    if (!jsonContent && options.jsonGenerator) {
      jsonContent = options.jsonGenerator();
    }
    
    if (jsonContent) {
      await writeFile(jsonPath, jsonContent, 'utf8');
      logger.info(`JSON configuration written to: ${jsonPath}`);
    }
  }
};

// Generate DHCP configuration file content
export const generateDhcpdConf = (config: DhcpConfiguration): string => {
  let conf = `# DHCP Server Configuration
# Generated by Server Manager on ${new Date().toISOString()}
# Configuration version: 1.0

`;

  // Global options
  if (config.domainName) {
    conf += `option domain-name "${config.domainName}";\n`;
  }
  
  if (config.domainNameServers?.length) {
    conf += `option domain-name-servers ${config.domainNameServers.join(', ')};\n`;
  }
  
  conf += `default-lease-time ${config.defaultLeaseTime || 86400};\n`;
  conf += `max-lease-time ${config.maxLeaseTime || 604800};\n`;
  
  if (config.authoritative) {
    conf += `authoritative;\n`;
  }
  
  if (config.ddnsUpdateStyle && config.ddnsUpdateStyle !== 'none') {
    conf += `ddns-update-style ${config.ddnsUpdateStyle};\n`;
  } else {
    conf += `ddns-update-style none;\n`;
  }
  
  if (config.logFacility) {
    conf += `log-facility ${config.logFacility};\n`;
  }
  
  conf += '\n';

  // Global custom options
  if (config.globalOptions?.length) {
    conf += `# Global Options\n`;
    config.globalOptions.forEach(option => {
      conf += `option ${option.name} ${option.value};\n`;
    });
    conf += '\n';
  }

  // Subnets
  config.subnets.forEach((subnet, index) => {
    conf += `# Subnet ${index + 1}: ${subnet.network}/${subnet.netmask}\n`;
    conf += `subnet ${subnet.network} netmask ${subnet.netmask} {\n`;
    
    if (subnet.range) {
      conf += `  range ${subnet.range.start} ${subnet.range.end};\n`;
    }
    
    if (subnet.defaultGateway) {
      conf += `  option routers ${subnet.defaultGateway};\n`;
    }
    
    if (subnet.domainNameServers?.length) {
      conf += `  option domain-name-servers ${subnet.domainNameServers.join(', ')};\n`;
    }
    
    if (subnet.broadcastAddress) {
      conf += `  option broadcast-address ${subnet.broadcastAddress};\n`;
    }
    
    if (subnet.subnetMask) {
      conf += `  option subnet-mask ${subnet.subnetMask};\n`;
    }
    
    // Subnet-specific pools
    if (subnet.pools?.length) {
      subnet.pools.forEach((pool, poolIndex) => {
        conf += `  \n  # Pool ${poolIndex + 1}\n`;
        conf += `  pool {\n`;
        conf += `    range ${pool.range.start} ${pool.range.end};\n`;
        
        if (pool.allowMembers?.length) {
          pool.allowMembers.forEach(member => {
            conf += `    allow members of "${member}";\n`;
          });
        }
        
        if (pool.denyMembers?.length) {
          pool.denyMembers.forEach(member => {
            conf += `    deny members of "${member}";\n`;
          });
        }
        
        conf += `  }\n`;
      });
    }
    
    // Subnet-specific options
    if (subnet.options?.length) {
      subnet.options.forEach(option => {
        conf += `  option ${option.name} ${option.value};\n`;
      });
    }
    
    conf += `}\n\n`;
  });

  // Host reservations
  if (config.hostReservations?.length) {
    conf += `# Static Host Reservations\n`;
    config.hostReservations.forEach(host => {
      conf += `host ${host.hostname} {\n`;
      conf += `  hardware ethernet ${host.macAddress};\n`;
      conf += `  fixed-address ${host.fixedAddress};\n`;
      
      if (host.options?.length) {
        host.options.forEach(option => {
          conf += `  option ${option.name} ${option.value};\n`;
        });
      }
      
      conf += `}\n\n`;
    });
  }

  return conf;
};

// Validate DHCP configuration syntax
const validateDhcpConfigSyntax = async (): Promise<void> => {
  if (!isProd) {
    logger.info('Skipping DHCP configuration validation in development mode');
    return;
  }
  
  try {
    await execAsync(`dhcpd -t -cf ${DHCPD_CONF_PATH}`);
    logger.info('DHCP configuration validation successful');
  } catch (error) {
    logger.error('DHCP configuration validation failed:', error);
    throw new Error(`DHCP configuration validation failed: ${(error as Error).message}`);
  }
};

// Reload DHCP service
const reloadDhcpService = async (listenInterface?: string): Promise<void> => {
  try {
    // If interface is specified, we need to configure the service to listen on it
    if (listenInterface && isProd) {
      // Create systemd override to specify interface
      const overrideDir = '/etc/systemd/system/dhcpd.service.d';
      const overrideFile = `${overrideDir}/interface.conf`;
      
      try {
        await ensureDirectoryExists(overrideDir);
        const overrideContent = `[Service]
ExecStart=
ExecStart=/usr/sbin/dhcpd -f -d --no-pid -cf ${DHCPD_CONF_PATH} ${listenInterface}
`;
        await writeFile(overrideFile, overrideContent, 'utf8');
        logger.info(`Created systemd override for interface ${listenInterface}`);
        
        // Reload systemd to pick up the changes
        await execAsync('systemctl daemon-reload');
      } catch (error) {
        logger.warn('Failed to create systemd override, service may not bind to specific interface:', error);
      }
    }
    
    await serviceManager.restart('dhcpd');
    logger.info('DHCP service reloaded successfully');
  } catch (error) {
    logger.error('Failed to reload DHCP service:', error);
    throw new Error(`Failed to reload DHCP service: ${(error as Error).message}`);
  }
};

// Update DHCP configuration
export const updateDhcpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    logger.info('Received DHCP configuration update request');
    
    // Validate request body
    const validatedFormData: DhcpConfigFormValues = dhcpConfigSchema.parse(req.body);
    const validatedConfig: DhcpConfiguration = transformDhcpFormToApi(validatedFormData);

    logger.info('DHCP Configuration validated successfully', { 
      subnets: validatedConfig.subnets.length,
      hostReservations: validatedConfig.hostReservations.length,
      globalOptions: validatedConfig.globalOptions?.length || 0
    });

    // Ensure directories exist
    await ensureDirectoryExists(DHCPD_CONF_DIR);
    await ensureDirectoryExists(DHCPD_BACKUP_DIR);

    // Generate configuration content
    const dhcpdConf = generateDhcpdConf(validatedConfig);

    // Write configuration with backup
    await writeFileWithBackup(DHCPD_CONF_PATH, dhcpdConf, {
      writeJsonVersion: true,
      jsonGenerator: () => JSON.stringify(validatedConfig, null, 2)
    });

    // Validate configuration syntax
    await validateDhcpConfigSyntax();

    // Reload service if enabled
    if (validatedConfig.dhcpServerStatus) {
      try {
        await reloadDhcpService(validatedConfig.listenInterface);
      } catch (error) {
        logger.warn('Service reload failed, but configuration was saved');
        return res.status(207).json({
          success: true,
          message: 'DHCP configuration updated successfully, but service reload failed',
          data: validatedConfig,
          warning: (error as Error).message
        });
      }
    }

    logger.info('DHCP configuration update completed successfully');
    res.status(200).json({
      success: true,
      message: 'DHCP configuration updated successfully',
      data: validatedConfig
    });

  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn('DHCP configuration validation error:', error.errors);
      return res.status(400).json({
        success: false,
        message: 'Validation Error',
        errors: error.errors
      });
    }

    logger.error('Error updating DHCP configuration:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to update DHCP configuration'
    });
  }
};

// Get current DHCP configuration
export const getCurrentDhcpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    logger.info('Fetching current DHCP configuration');
    
    const confJsonPath = `${DHCPD_CONF_PATH}.json`;

    // Check service status
    let serviceRunning = false;
    try {
      serviceRunning = await serviceManager.status('dhcpd');
    } catch (error) {
      logger.warn('Failed to check DHCP service status:', error);
    }

    // Try to read existing configuration
    try {
      const configData = await readFile(confJsonPath, 'utf8');
      const config: DhcpConfiguration = JSON.parse(configData);
      config.dhcpServerStatus = serviceRunning;

      logger.info('DHCP configuration loaded from file');
      res.status(200).json({
        success: true,
        message: 'Current DHCP configuration loaded successfully',
        data: config
      });
    } catch (error) {
      logger.info('No existing DHCP configuration found, returning default');
      
      // Return default configuration if none exists
      const defaultConfig: DhcpConfiguration = {
        dhcpServerStatus: serviceRunning,
        domainName: 'local',
        domainNameServers: ['8.8.8.8', '8.8.4.4'],
        defaultLeaseTime: 86400,
        maxLeaseTime: 604800,
        authoritative: true,
        ddnsUpdateStyle: 'none',
        listenInterface: '', // Will be set by user
        subnets: [{
          id: crypto.randomUUID(),
          network: '192.168.1.0',
          netmask: '255.255.255.0',
          range: {
            start: '192.168.1.100',
            end: '192.168.1.200'
          },
          defaultGateway: '192.168.1.1',
          domainNameServers: ['8.8.8.8', '8.8.4.4']
        }],
        hostReservations: [],
        globalOptions: []
      };

      res.status(200).json({
        success: true,
        message: 'Default DHCP configuration returned',
        data: defaultConfig
      });
    }
  } catch (error) {
    logger.error('Error getting DHCP configuration:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to get DHCP configuration'
    });
  }
};

// Get network interfaces
export const getNetworkInterfaces = async (req: AuthRequest, res: Response) => {
  try {
    logger.info('Fetching network interfaces');
    
    if (config.useMockServices) {
      // Return mock interfaces for development
      const mockInterfaces: NetworkInterface[] = [
        {
          name: 'eth0',
          ipAddress: '192.168.1.10',
          netmask: '255.255.255.0',
          broadcast: '192.168.1.255',
          macAddress: '00:11:22:33:44:55',
          state: 'UP',
          type: 'physical'
        },
        {
          name: 'enp0s3',
          ipAddress: '10.0.2.15',
          netmask: '255.255.255.0',
          broadcast: '10.0.2.255',
          macAddress: '08:00:27:12:34:56',
          state: 'UP',
          type: 'physical'
        },
        {
          name: 'lo',
          ipAddress: '127.0.0.1',
          netmask: '255.0.0.0',
          state: 'UP',
          type: 'loopback'
        }
      ];
      
      return res.status(200).json({
        success: true,
        message: 'Network interfaces retrieved successfully (mock)',
        data: mockInterfaces
      } as NetworkInterfaceResponse);
    }

    // Get network interfaces using ip command
    const { stdout } = await execAsync('ip -j addr show');
    const interfaces = JSON.parse(stdout);
    
    const networkInterfaces: NetworkInterface[] = interfaces
      .filter((iface: any) => iface.ifname !== 'lo' || iface.ifname === 'lo') // Include all for now
      .map((iface: any) => {
        const addr = iface.addr_info?.find((addr: any) => addr.family === 'inet');
        
        return {
          name: iface.ifname,
          ipAddress: addr?.local,
          netmask: addr ? convertPrefixToNetmask(addr.prefixlen) : undefined,
          broadcast: addr?.broadcast,
          macAddress: iface.address,
          state: iface.operstate === 'UP' ? 'UP' : iface.operstate === 'DOWN' ? 'DOWN' : 'UNKNOWN',
          type: iface.ifname === 'lo' ? 'loopback' : 
                iface.ifname.startsWith('vir') || iface.ifname.startsWith('veth') || 
                iface.ifname.startsWith('docker') || iface.ifname.startsWith('br-') ? 'virtual' : 'physical'
        } as NetworkInterface;
      })
      .filter((iface: NetworkInterface) => iface.state === 'UP'); // Only return UP interfaces

    logger.info(`Found ${networkInterfaces.length} network interfaces`);
    res.status(200).json({
      success: true,
      message: 'Network interfaces retrieved successfully',
      data: networkInterfaces
    } as NetworkInterfaceResponse);

  } catch (error) {
    logger.error('Error getting network interfaces:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to get network interfaces',
      data: []
    } as NetworkInterfaceResponse);
  }
};

// Helper function to convert prefix length to netmask
const convertPrefixToNetmask = (prefixlen: number): string => {
  const mask = (0xffffffff << (32 - prefixlen)) >>> 0;
  return [
    (mask >>> 24) & 0xff,
    (mask >>> 16) & 0xff,
    (mask >>> 8) & 0xff,
    mask & 0xff
  ].join('.');
};

// Validate DHCP configuration without saving
export const validateDhcpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    logger.info('Validating DHCP configuration');
    
    // Validate request body
    const validatedFormData: DhcpConfigFormValues = dhcpConfigSchema.parse(req.body);
    const validatedConfig: DhcpConfiguration = transformDhcpFormToApi(validatedFormData);

    // Generate configuration content for validation
    const dhcpdConf = generateDhcpdConf(validatedConfig);

    // In production, test the configuration syntax
    if (isProd) {
      const tempFile = `/tmp/dhcpd-test-${Date.now()}.conf`;
      try {
        await writeFile(tempFile, dhcpdConf, 'utf8');
        await execAsync(`dhcpd -t -cf ${tempFile}`);
        await fs.promises.unlink(tempFile);
      } catch (error) {
        try {
          await fs.promises.unlink(tempFile);
        } catch {}
        throw new Error(`Configuration syntax error: ${(error as Error).message}`);
      }
    }

    logger.info('DHCP configuration validation successful');
    res.status(200).json({
      success: true,
      message: 'DHCP configuration is valid',
      valid: true,
      data: validatedConfig
    });

  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn('DHCP configuration validation error:', error.errors);
      return res.status(400).json({
        success: false,
        message: 'Validation Error',
        valid: false,
        errors: error.errors
      });
    }

    logger.error('Error validating DHCP configuration:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to validate DHCP configuration',
      valid: false
    });
  }
};

// Get DHCP service status
export const getDhcpServiceStatus = async (req: AuthRequest, res: Response) => {
  try {
    logger.info('Checking DHCP service status');
    
    const isRunning = await serviceManager.status('dhcpd');
    const detailedStatus = await serviceManager.getDetailedStatus('dhcpd');
    
    const status: DhcpServiceResponse = {
      service: 'dhcpd',
      status: isRunning ? 'running' : 'stopped',
      message: detailedStatus
    };

    logger.info(`DHCP service status: ${status.status}`);
    res.status(200).json({
      success: true,
      data: status,
      message: `DHCP service is ${status.status}`
    });

  } catch (error) {
    logger.error('Error checking DHCP service status:', error);
    
    const status: DhcpServiceResponse = {
      service: 'dhcpd',
      status: 'unknown',
      message: error instanceof Error ? error.message : 'Failed to check service status'
    };

    res.status(500).json({
      success: false,
      data: status,
      message: 'Failed to check DHCP service status'
    });
  }
};

// Control DHCP service (start/stop/restart)
export const controlDhcpService = async (req: AuthRequest, res: Response) => {
  try {
    const { action } = req.params;
    const validActions = ['start', 'stop', 'restart', 'reload', 'status'];
    
    if (!validActions.includes(action)) {
      return res.status(400).json({
        success: false,
        message: `Invalid action: ${action}. Valid actions are: ${validActions.join(', ')}`
      });
    }

    logger.info(`Executing DHCP service action: ${action}`);
    
    let result: string;
    let isRunning: boolean;

    switch (action) {
      case 'start':
        result = await serviceManager.start('dhcpd');
        isRunning = await serviceManager.status('dhcpd');
        break;
      case 'stop':
        result = await serviceManager.stop('dhcpd');
        isRunning = await serviceManager.status('dhcpd');
        break;
      case 'restart':
      case 'reload':
        result = await serviceManager.restart('dhcpd');
        isRunning = await serviceManager.status('dhcpd');
        break;
      case 'status':
        result = await serviceManager.getDetailedStatus('dhcpd');
        isRunning = await serviceManager.status('dhcpd');
        break;
      default:
        throw new Error(`Unsupported action: ${action}`);
    }

    const status: DhcpServiceResponse = {
      service: 'dhcpd',
      status: isRunning ? 'running' : 'stopped',
      message: result
    };

    logger.info(`DHCP service ${action} completed: ${status.status}`);
    res.status(200).json({
      success: true,
      data: status,
      message: `DHCP service ${action} executed successfully`
    });

  } catch (error) {
    logger.error(`Error executing DHCP service action ${req.params.action}:`, error);
    
    const status: DhcpServiceResponse = {
      service: 'dhcpd',
      status: 'failed',
      message: error instanceof Error ? error.message : `Failed to ${req.params.action} DHCP service`
    };

    res.status(500).json({
      success: false,
      data: status,
      message: `Failed to ${req.params.action} DHCP service`
    });
  }
}; 