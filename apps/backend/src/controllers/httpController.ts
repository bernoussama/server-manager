import type { Response } from 'express';
import type { AuthRequest } from '../middlewares/authMiddleware';
import { httpConfigSchema, transformHttpFormToApi, transformHttpApiToForm, type HttpConfigFormValues } from '@server-manager/shared/validators';
import type { HttpConfiguration, HttpVirtualHost, HttpGlobalConfig, HttpServiceResponse, HttpDirective, HttpLogConfig, HttpDirectoryConfig } from '@server-manager/shared';
import { ZodError } from 'zod';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { existsSync } from 'fs';
import crypto from 'crypto';
import fs from 'fs';
import logger from '../lib/logger.js';
import { ServiceManager } from '../lib/ServiceManager.js';

const execAsync = promisify(exec);
const serviceManager = new ServiceManager();

// --- BEGIN Configuration ---
// Determine paths based on environment
const isProd = process.env.NODE_ENV === 'production';

// Directories where configuration files will be stored
const HTTPD_CONF_DIR = isProd ? '/etc/httpd/conf' : './test/http/config';
const HTTPD_VHOST_DIR = isProd ? '/etc/httpd/conf.d' : './test/http/vhost';
const HTTPD_CONF_PATH = isProd ? '/etc/httpd/conf/httpd.conf' : './test/http/config/httpd.conf';
const HTTPD_BACKUP_DIR = isProd ? '/etc/httpd/conf/backups' : './test/http/backups';

// Default configuration values
const DEFAULT_HTTPD_CONFIG = {
  serverRoot: '/etc/httpd',
  serverName: 'www.srv.world:80',
  serverAdmin: 'root@srv.world',
  listen: [{ port: 80 }, { port: 443, ssl: true }],
  timeout: 60,
  keepAlive: true,
  keepAliveTimeout: 5,
  maxKeepAliveRequests: 100,
  serverTokens: 'Prod' as const,
  serverSignature: 'Off' as const
};
// --- END Configuration ---

/**
 * Ensure directory exists, create if not
 */
const ensureDirectoryExists = async (dir: string): Promise<void> => {
  if (!existsSync(dir)) {
    try {
      logger.info(`Creating directory: ${dir}`);
      await mkdir(dir, { recursive: true });
      logger.info(`Directory created: ${dir}`);
    } catch (error) {
      logger.error(`Error creating directory ${dir}:`, error);
      throw new Error(`Failed to create directory ${dir}: ${(error as Error).message}`);
    }
  }
};

/**
 * Check if we have write permission for a file
 */
const checkWritePermission = async (filePath: string): Promise<boolean> => {
  try {
    // Try to create the directory if it doesn't exist
    const dir = path.dirname(filePath);
    await ensureDirectoryExists(dir);
    
    // Try to write a test file
    const testFile = path.join(dir, '.test-write-permission');
    await writeFile(testFile, 'test');
    await fs.promises.unlink(testFile);
    return true;
  } catch (error) {
    logger.error(`No write permission for ${filePath}:`, error);
    return false;
  }
};

/**
 * Write file with backup functionality
 */
const writeFileWithBackup = async (
  filePath: string, 
  content: string, 
  options?: {
    writeJsonVersion?: boolean;
    jsonContent?: string;
    jsonGenerator?: () => string;
  }
): Promise<void> => {
  try {
    const dir = path.dirname(filePath);
    await ensureDirectoryExists(dir);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);

    // Create backup if file exists
    if (existsSync(filePath)) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(HTTPD_BACKUP_DIR, `${path.basename(filePath)}.${timestamp}.backup`);
      
      try {
        const existingContent = await readFile(filePath, 'utf8');
        await writeFile(backupPath, existingContent);
        logger.info(`Backup created: ${backupPath}`);
      } catch (error) {
        logger.error(`Failed to create backup for ${filePath}:`, error);
        throw new Error(`Failed to create backup: ${(error as Error).message}`);
      }
    }

    // Write new content
    await writeFile(filePath, content);
    logger.info(`Successfully wrote ${filePath}`);

    // Write JSON version if requested
    if (options?.writeJsonVersion) {
      const jsonPath = `${filePath}.json`;
      const jsonContent = options.jsonContent || (options.jsonGenerator ? options.jsonGenerator() : '{}');
      await writeFile(jsonPath, jsonContent);
      logger.info(`Successfully wrote JSON metadata: ${jsonPath}`);
    }
  } catch (error) {
    logger.error(`Error writing file ${filePath}:`, error);
    throw new Error(`Failed to write file: ${(error as Error).message}`);
  }
};

/**
 * Generate httpd.conf content
 */
export const generateHttpdConf = (config: HttpConfiguration): string => {
  const { globalConfig } = config;
  
  let conf = `# Generated by Server Manager
# DO NOT EDIT MANUALLY - Changes will be overwritten

ServerRoot "${globalConfig.serverRoot || DEFAULT_HTTPD_CONFIG.serverRoot}"

# Required modules
`;

  // Check if SSL is needed for any listen directive
  const needsSSL = globalConfig.listen.some((listen: { port: number; address?: string; ssl?: boolean }) => listen.ssl);
  
  // Add enabled modules from configuration
  if (globalConfig.modules && globalConfig.modules.length > 0) {
    globalConfig.modules
      .filter((module: any) => module.enabled)
      .forEach((module: any) => {
        conf += `LoadModule ${module.name}_module ${module.filename || `modules/mod_${module.name}.so`}\n`;
      });
      
    // Auto-enable SSL module if needed but not explicitly enabled
    const sslModule = globalConfig.modules.find((module: any) => module.name === 'ssl');
    if (needsSSL && (!sslModule || !sslModule.enabled)) {
      conf += `# SSL module auto-enabled (ensure mod_ssl is installed: dnf install httpd-mod_ssl)\n`;
      conf += `LoadModule ssl_module modules/mod_ssl.so\n`;
      logger.info('Auto-enabled SSL module because SSL listen directive found');
    }
  } else {
    // Fallback to default modules if none specified
    // Load essential modules first, in dependency order
    conf += `# Essential Apache modules (install missing ones with: dnf install httpd mod_ssl)
# Core modules for basic functionality
LoadModule mpm_event_module modules/mod_mpm_event.so
LoadModule authz_core_module modules/mod_authz_core.so
LoadModule authz_host_module modules/mod_authz_host.so

# Logging support (required for CustomLog directive)
LoadModule log_config_module modules/mod_log_config.so

# Content handling
LoadModule mime_module modules/mod_mime.so
LoadModule dir_module modules/mod_dir.so
LoadModule alias_module modules/mod_alias.so

# URL rewriting
LoadModule rewrite_module modules/mod_rewrite.so

# SSL support (ensure mod_ssl package is installed)
LoadModule ssl_module modules/mod_ssl.so

# Unix domain socket handling (required for User/Group directives)
LoadModule unixd_module modules/mod_unixd.so
`;
  }

  // Listen directives - include SSL listeners if SSL module is enabled or auto-enabled
  const sslModule = globalConfig.modules?.find((module: any) => module.name === 'ssl');
  const sslAvailable = !globalConfig.modules || // no modules config means defaults used (SSL included)
                      (sslModule && sslModule.enabled) || // SSL explicitly enabled
                      (needsSSL && sslModule && !sslModule.enabled); // SSL auto-enabled above
  
  globalConfig.listen.forEach((listen: { port: number; address?: string; ssl?: boolean }) => {
    if (listen.ssl && sslAvailable) {
      conf += `Listen ${listen.address || '*'}:${listen.port} ssl\n`;
    } else if (!listen.ssl) {
      conf += `Listen ${listen.address || '*'}:${listen.port}\n`;
    } else if (listen.ssl && !sslAvailable) {
      logger.warn(`Skipping SSL listen directive for port ${listen.port} because SSL module is disabled`);
    }
  });

  conf += `
# Server identification
ServerName ${globalConfig.serverName || DEFAULT_HTTPD_CONFIG.serverName}
ServerAdmin ${globalConfig.serverAdmin || DEFAULT_HTTPD_CONFIG.serverAdmin}

# Security settings
ServerTokens ${globalConfig.serverTokens || DEFAULT_HTTPD_CONFIG.serverTokens}
ServerSignature ${globalConfig.serverSignature || DEFAULT_HTTPD_CONFIG.serverSignature}
User ${globalConfig.user || 'apache'}
Group ${globalConfig.group || 'apache'}
`;

  if (globalConfig.keepAlive) {
    conf += `KeepAliveTimeout ${globalConfig.keepAliveTimeout || DEFAULT_HTTPD_CONFIG.keepAliveTimeout}
MaxKeepAliveRequests ${globalConfig.maxKeepAliveRequests || DEFAULT_HTTPD_CONFIG.maxKeepAliveRequests}
`;
  }

  // Process management settings
  if (globalConfig.startServers) {
    conf += `\n# Process management
StartServers ${globalConfig.startServers}
`;
    if (globalConfig.minSpareServers) conf += `MinSpareServers ${globalConfig.minSpareServers}\n`;
    if (globalConfig.maxSpareServers) conf += `MaxSpareServers ${globalConfig.maxSpareServers}\n`;
    if (globalConfig.maxRequestWorkers) conf += `MaxRequestWorkers ${globalConfig.maxRequestWorkers}\n`;
    if (globalConfig.serverLimit) conf += `ServerLimit ${globalConfig.serverLimit}\n`;
  }

  // Global logging
  if (globalConfig.errorLog) {
    conf += `\n# Global logging
ErrorLog ${globalConfig.errorLog}
`;
    if (globalConfig.logLevel) {
      conf += `LogLevel ${globalConfig.logLevel}\n`;
    }
  }

  // Custom global directives
  if (globalConfig.customDirectives && globalConfig.customDirectives.length > 0) {
    conf += '\n# Custom global directives\n';
    globalConfig.customDirectives.forEach((directive: HttpDirective) => {
      if (directive.comment) {
        conf += `# ${directive.comment}\n`;
      }
      conf += `${directive.name} ${directive.value}\n`;
    });
  }

  // Include virtual host configurations
  conf += `\n# Virtual Host configurations
Include conf.d/*.conf

# Default document root
DocumentRoot "/var/www/html"

# Default directory permissions
<Directory "/var/www">
    AllowOverride None
    Require all denied
</Directory>

<Directory "/var/www/html">
    Options FollowSymLinks
    AllowOverride All
    Require all granted
    DirectoryIndex index.html index.php index.cgi
</Directory>
`;

  return conf;
};

/**
 * Generate virtual host configuration file
 */
const generateVirtualHostConf = (vhost: HttpVirtualHost): string => {
  const portSpec = vhost.ipAddress ? `${vhost.ipAddress}:${vhost.port}` : `*:${vhost.port}`;
  
  let conf = `# Virtual Host: ${vhost.serverName}
# Generated by HTTP Management System
# REQUIRES: Main httpd.conf with proper module loading
# This file depends on modules loaded in /etc/httpd/conf/httpd.conf

<VirtualHost ${portSpec}>
    ServerName ${vhost.serverName}
`;

  // Server aliases
  if (vhost.serverAlias && vhost.serverAlias.length > 0) {
    conf += `    ServerAlias ${vhost.serverAlias.join(' ')}\n`;
  }

  conf += `    DocumentRoot "${vhost.documentRoot}"\n`;

  // Directory index
  if (vhost.directoryIndex && vhost.directoryIndex.length > 0) {
    conf += `    DirectoryIndex ${vhost.directoryIndex.join(' ')}\n`;
  }

  // Logging
  if (vhost.errorLog) {
    conf += `    ErrorLog "${vhost.errorLog}"\n`;
  }
  
  if (vhost.customLog && vhost.customLog.length > 0) {
    vhost.customLog.forEach((log: HttpLogConfig) => {
      conf += `    CustomLog "${log.path}" ${log.format || 'combined'}\n`;
    });
  }

  if (vhost.logLevel) {
    conf += `    LogLevel ${vhost.logLevel}\n`;
  }

  // SSL Configuration
  if (vhost.ssl?.enabled) {
    conf += `\n    # SSL Configuration
    SSLEngine ${vhost.ssl.sslEngine ? 'on' : 'off'}
`;
    if (vhost.ssl.certificateFile) {
      conf += `    SSLCertificateFile "${vhost.ssl.certificateFile}"\n`;
    }
    if (vhost.ssl.certificateKeyFile) {
      conf += `    SSLCertificateKeyFile "${vhost.ssl.certificateKeyFile}"\n`;
    }
    if (vhost.ssl.certificateChainFile) {
      conf += `    SSLCertificateChainFile "${vhost.ssl.certificateChainFile}"\n`;
    }
    if (vhost.ssl.sslProtocol && vhost.ssl.sslProtocol.length > 0) {
      conf += `    SSLProtocol ${vhost.ssl.sslProtocol.join(' ')}\n`;
    }
    if (vhost.ssl.sslCipherSuite) {
      conf += `    SSLCipherSuite "${vhost.ssl.sslCipherSuite}"\n`;
    }
  }

  // Directory configurations
  if (vhost.directories && vhost.directories.length > 0) {
    vhost.directories.forEach((dir: HttpDirectoryConfig) => {
      conf += `\n    <Directory "${dir.path}">
`;
      if (dir.allowOverride) {
        conf += `        AllowOverride ${dir.allowOverride}\n`;
      }
      if (dir.options && dir.options.length > 0) {
        conf += `        Options ${dir.options.join(' ')}\n`;
      }
      if (dir.require && dir.require.length > 0) {
        dir.require.forEach((req: string) => {
          conf += `        Require ${req}\n`;
        });
      }
      if (dir.directoryIndex && dir.directoryIndex.length > 0) {
        conf += `        DirectoryIndex ${dir.directoryIndex.join(' ')}\n`;
      }
      if (dir.customDirectives && dir.customDirectives.length > 0) {
        dir.customDirectives.forEach((directive: HttpDirective) => {
          if (directive.comment) {
            conf += `        # ${directive.comment}\n`;
          }
          conf += `        ${directive.name} ${directive.value}\n`;
        });
      }
      conf += `    </Directory>\n`;
    });
  }

  // Redirects
  if (vhost.redirects && vhost.redirects.length > 0) {
    conf += '\n    # Redirects\n';
    vhost.redirects.forEach((redirect: { from: string; to: string; type: 'permanent' | 'temporary' | 'seeother' | 'gone' }) => {
      const redirectType = redirect.type === 'permanent' ? '301' : 
                          redirect.type === 'temporary' ? '302' : 
                          redirect.type === 'seeother' ? '303' : '410';
      conf += `    Redirect ${redirectType} ${redirect.from} ${redirect.to}\n`;
    });
  }

  // Rewrites
  if (vhost.rewrites && vhost.rewrites.length > 0) {
    conf += '\n    # Rewrites\n    RewriteEngine On\n';
    vhost.rewrites.forEach((rewrite: { pattern: string; substitution: string; flags?: string[] }) => {
      const flags = rewrite.flags && rewrite.flags.length > 0 ? ` [${rewrite.flags.join(',')}]` : '';
      conf += `    RewriteRule ${rewrite.pattern} ${rewrite.substitution}${flags}\n`;
    });
  }

  // Custom directives
  if (vhost.customDirectives && vhost.customDirectives.length > 0) {
    conf += '\n    # Custom directives\n';
    vhost.customDirectives.forEach((directive: HttpDirective) => {
      if (directive.comment) {
        conf += `    # ${directive.comment}\n`;
      }
      conf += `    ${directive.name} ${directive.value}\n`;
    });
  }

  conf += '</VirtualHost>\n';
  return conf;
};

/**
 * Validate Apache configuration syntax
 */
const validateHttpdConfiguration = async (): Promise<void> => {
  try {
    if (isProd) {
      const { stdout, stderr } = await execAsync('httpd -t');
      logger.info('Apache configuration validation passed:', stdout);
    } else {
      // In development, just check if config files exist and are readable
      if (existsSync(HTTPD_CONF_PATH)) {
        await readFile(HTTPD_CONF_PATH, 'utf8');
      }
    }
    logger.info('Apache configuration validation passed');
  } catch (error: any) {
    logger.error('Apache configuration validation failed:', error);
    
    // Provide specific help for common issues
    const errorMessage = error.message || error.stderr || error.stdout || String(error);
    let helpMessage = 'Configuration validation failed';
    
    if (errorMessage.includes('CustomLog') || errorMessage.includes('mod_log_config')) {
      helpMessage = 'mod_log_config module is not available. Install with: dnf install httpd';
    } else if (errorMessage.includes('mod_ssl')) {
      helpMessage = 'mod_ssl module is not available. Install with: dnf install mod_ssl';
    } else if (errorMessage.includes('Invalid command')) {
      helpMessage = 'Missing Apache module. Check that all required modules are installed.';
    }
    
    throw new Error(`${helpMessage}: ${errorMessage}`);
  }
};

/**
 * Reload Apache service
 */
const reloadHttpdService = async (): Promise<void> => {
  try {
    if (isProd) {
      await serviceManager.restart('httpd');
    } else {
      logger.info('Development mode: skipping actual service reload');
    }
    logger.info('Apache service reloaded successfully');
  } catch (error) {
    logger.error('Failed to reload Apache service:', error);
    throw new Error(`Failed to reload Apache service: ${(error as Error).message}`);
  }
};

/**
 * Get current HTTP configuration
 */
export const getCurrentHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    logger.debug(`Running in ${isProd ? 'PRODUCTION' : 'DEVELOPMENT'} mode`);
    logger.debug(`Using HTTPD_CONF_PATH: ${HTTPD_CONF_PATH}`);
    
    // Get the status of the httpd service
    let serviceRunning = false;
    if (isProd) {
      try {
        // First check if the service exists
        const serviceExists = await serviceManager.exists('httpd');
        if (serviceExists) {
          serviceRunning = await serviceManager.status('httpd');
          logger.info(`Apache service is ${serviceRunning ? 'running' : 'not running'}`);
        } else {
          logger.warn('Apache httpd service is not installed. Install with: sudo dnf install httpd');
        }
      } catch (error) {
        logger.info('Error checking Apache service status, assuming not running');
      }
    }
    
    // Path to the JSON configuration file
    const httpdConfJsonPath = `${HTTPD_CONF_PATH}.json`;
    
    // Try to read the JSON configuration file
    let configJson = null;
    
    try {
      const configData = await readFile(httpdConfJsonPath, 'utf8');
      configJson = JSON.parse(configData);
      logger.debug(`Successfully read httpd.conf.json from ${httpdConfJsonPath}`);
    } catch (error) {
      logger.info(`httpd.conf.json does not exist or is invalid at ${httpdConfJsonPath}`);
    }
    
    // If JSON configuration file doesn't exist, return a default configuration
    if (!configJson) {
      logger.info('No existing JSON configuration found, returning default configuration');
      const defaultConfig: HttpConfiguration = {
        serverStatus: serviceRunning,
        globalConfig: {
          ...DEFAULT_HTTPD_CONFIG,
          user: 'apache',
          group: 'apache',
          errorLog: '/var/log/httpd/error_log',
          logLevel: 'warn',
          modules: [
            {
              name: 'mpm_event',
              enabled: true,
              required: true,
              description: 'Event-driven processing module (recommended for most configurations)',
              filename: 'modules/mod_mpm_event.so'
            },
            {
              name: 'dir',
              enabled: true,
              required: true,
              description: 'Directory index handling',
              filename: 'modules/mod_dir.so'
            },
            {
              name: 'mime',
              enabled: true,
              required: true,
              description: 'MIME type associations',
              filename: 'modules/mod_mime.so'
            },
            {
              name: 'rewrite',
              enabled: true,
              required: false,
              description: 'URL rewriting engine',
              filename: 'modules/mod_rewrite.so'
            },
            {
              name: 'ssl',
              enabled: true,
              required: false,
              description: 'SSL/TLS encryption support',
              filename: 'modules/mod_ssl.so'
            },
            {
              name: 'alias',
              enabled: true,
              required: false,
              description: 'URL aliasing and redirection',
              filename: 'modules/mod_alias.so'
            },
            {
              name: 'authz_core',
              enabled: true,
              required: true,
              description: 'Core authorization functionality',
              filename: 'modules/mod_authz_core.so'
            },
            {
              name: 'authz_host',
              enabled: true,
              required: false,
              description: 'Host-based authorization',
              filename: 'modules/mod_authz_host.so'
            },
            {
              name: 'log_config',
              enabled: true,
              required: false,
              description: 'Logging configuration',
              filename: 'modules/mod_log_config.so'
            },
            {
              name: 'unixd',
              enabled: true,
              required: true,
              description: 'Unix domain socket handling module (required for User/Group directives)',
              filename: 'modules/mod_unixd.so'
            }
          ]
        },
        virtualHosts: [
          {
            id: crypto.randomUUID(),
            enabled: true,
            serverName: 'www.srv.world',
            documentRoot: '/var/www/html',
            port: 80,
            directoryIndex: ['index.html', 'index.php', 'index.cgi'],
            errorLog: '/var/log/httpd/www.srv.world_error.log',
            customLog: [
              {
                type: 'access',
                path: '/var/log/httpd/www.srv.world_access.log',
                format: 'combined'
              }
            ]
          }
        ]
      };
      
      return res.status(200).json({
        message: 'Default configuration returned - no existing configuration found',
        data: defaultConfig
      });
    }
    
    // Add service status to the configuration
    configJson.serverStatus = serviceRunning;
    
    logger.info('Successfully loaded current HTTP configuration from JSON file');
    res.status(200).json({ 
      message: 'Current HTTP configuration loaded successfully',
      data: configJson 
    });
  } catch (error) {
    logger.error('Error getting HTTP configuration:', error);
    res.status(500).json({ 
      message: error instanceof Error ? error.message : 'Failed to get HTTP configuration' 
    });
  }
};

/**
 * Update HTTP configuration
 */
export const updateHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    // Validate the request body
    const validatedFormData: HttpConfigFormValues = httpConfigSchema.parse(req.body);
    
    // Transform form data to API format
    const validatedConfig: HttpConfiguration = transformHttpFormToApi(validatedFormData);

    logger.info('Received HTTP Configuration:', { config: JSON.stringify(validatedConfig, null, 2) });
    logger.debug(`Running in ${isProd ? 'PRODUCTION' : 'DEVELOPMENT'} mode`);
    logger.debug(`Using HTTPD_CONF_PATH: ${HTTPD_CONF_PATH}`);
    logger.debug(`Using HTTPD_VHOST_DIR: ${HTTPD_VHOST_DIR}`);
    
    // In production, check permissions
    if (isProd) {
      const canWriteConf = await checkWritePermission(HTTPD_CONF_PATH);
      const canWriteVhost = await checkWritePermission(path.join(HTTPD_VHOST_DIR, 'test.conf'));
      
      if (!canWriteConf || !canWriteVhost) {
        return res.status(403).json({
          message: 'Insufficient permissions',
          details: 'The server needs write access to HTTP configuration directories. Please run with sudo or check permissions.',
          paths: {
            canWriteConf,
            canWriteVhost,
            httpdConfPath: HTTPD_CONF_PATH,
            httpdVhostDir: HTTPD_VHOST_DIR
          }
        });
      }
    }
    
    // Ensure required directories exist
    await ensureDirectoryExists(HTTPD_CONF_DIR);
    await ensureDirectoryExists(HTTPD_VHOST_DIR);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);
    
    // IMPORTANT: Generate and write main httpd.conf FIRST
    // This ensures all required modules are loaded before virtual hosts
    logger.info('Generating main httpd.conf with required modules...');
    const httpdConf = generateHttpdConf(validatedConfig);
    await writeFileWithBackup(HTTPD_CONF_PATH, httpdConf, {
      writeJsonVersion: true,
      jsonGenerator: () => JSON.stringify(validatedConfig, null, 2)
    });
    logger.info(`Main httpd.conf written to ${HTTPD_CONF_PATH}`);
    
    // Remove existing virtual host files (cleanup)
    try {
      const vhostFiles = await fs.promises.readdir(HTTPD_VHOST_DIR);
      for (const file of vhostFiles) {
        if (file.endsWith('.conf') && !file.startsWith('.')) {
          await fs.promises.unlink(path.join(HTTPD_VHOST_DIR, file));
        }
      }
    } catch (error) {
      logger.warn('Could not clean up existing virtual host files:', error);
    }
    
    // Generate and write virtual host files
    for (const vhost of validatedConfig.virtualHosts) {
      if (vhost.enabled) {
        const vhostConf = generateVirtualHostConf(vhost);
        const vhostFilePath = path.join(HTTPD_VHOST_DIR, `${vhost.serverName}.conf`);
        
        logger.info(`Generating virtual host file for ${vhost.serverName} at ${vhostFilePath}`);
        await writeFileWithBackup(vhostFilePath, vhostConf, {
          writeJsonVersion: true,
          jsonGenerator: () => JSON.stringify(vhost, null, 2)
        });
      }
    }
    
    // Validate Apache configuration
    try {
      await validateHttpdConfiguration();
    } catch (error) {
      return res.status(400).json({
        message: 'HTTP configuration validation failed',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
    
    // Only reload if the HTTP server is enabled
    if (validatedConfig.serverStatus) {
      try {
        await reloadHttpdService();
      } catch (error) {
        return res.status(500).json({
          message: 'Failed to reload HTTP server',
          error: error instanceof Error ? error.message : 'Unknown error',
          note: 'Configuration files were updated but service reload failed'
        });
      }
    } else {
      logger.info('HTTP server is disabled, skipping reload');
    }
    
    res.status(200).json({ 
      message: 'HTTP configuration updated successfully',
      data: validatedConfig 
    });

  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ 
        message: 'Validation Error', 
        errors: error.errors 
      });
    }
    
    logger.error('Error updating HTTP configuration:', error);
    res.status(500).json({ 
      message: error instanceof Error ? error.message : 'Failed to update HTTP configuration' 
    });
  }
};

/**
 * Validate HTTP configuration without applying changes
 */
export const validateHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    // Validate the request body format
    const validatedFormData: HttpConfigFormValues = httpConfigSchema.parse(req.body);
    const validatedConfig: HttpConfiguration = transformHttpFormToApi(validatedFormData);
    
    // Generate configuration content for validation
    const httpdConf = generateHttpdConf(validatedConfig);
    
    // Write to temporary file for validation
    const tempConfPath = path.join(HTTPD_BACKUP_DIR, `temp-httpd-${Date.now()}.conf`);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);
    await writeFile(tempConfPath, httpdConf);
    
    try {
      if (isProd) {
        // Use Apache's configuration test with temporary file
        await execAsync(`httpd -t -f ${tempConfPath}`);
      }
      
      // Clean up temporary file
      await fs.promises.unlink(tempConfPath);
      
      res.status(200).json({
        message: 'HTTP configuration validation passed',
        valid: true
      });
    } catch (error) {
      // Clean up temporary file on error
      try {
        await fs.promises.unlink(tempConfPath);
      } catch {}
      
      throw error;
    }
    
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ 
        message: 'Validation Error', 
        errors: error.errors,
        valid: false
      });
    }
    
    logger.error('HTTP configuration validation failed:', error);
    res.status(400).json({ 
      message: 'Configuration validation failed',
      error: error instanceof Error ? error.message : 'Unknown error',
      valid: false
    });
  }
};

/**
 * Get HTTP service status
 */
export const getHttpServiceStatus = async (req: AuthRequest, res: Response) => {
  try {
    let status: 'running' | 'stopped' | 'failed' | 'unknown' = 'unknown';
    let message = 'Service status unknown';
    
    if (isProd) {
      try {
        // Get the detailed service state
        const serviceState = await serviceManager.getServiceState('httpd');
        
        switch (serviceState) {
          case 'active':
            status = 'running';
            message = 'Apache service is running';
            break;
          case 'inactive':
            status = 'stopped';
            message = 'Apache service is stopped';
            break;
          case 'failed':
            status = 'failed';
            message = 'Apache service has failed. Check configuration and restart service.';
            break;
          case 'not-found':
            status = 'failed';
            message = 'Apache httpd service is not installed. Install with: sudo dnf install httpd';
            break;
          default:
            status = 'unknown';
            message = `Apache service state: ${serviceState}`;
        }
      } catch (error) {
        status = 'failed';
        message = `Failed to check service status: ${(error as Error).message}`;
      }
    } else {
      status = 'stopped';
      message = 'Development mode - service not managed';
    }
    
    const response: HttpServiceResponse = {
      service: 'httpd',
      status,
      message
    };
    
    res.status(200).json({
      success: true,
      data: response
    });
    
  } catch (error) {
    logger.error('Error getting HTTP service status:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to get service status'
    });
  }
};

/**
 * Control HTTP service (start, stop, restart, reload)
 */
export const controlHttpService = async (req: AuthRequest, res: Response) => {
  try {
    const { action } = req.params;
    
    if (!['start', 'stop', 'restart', 'reload', 'status'].includes(action)) {
      return res.status(400).json({
        success: false,
        message: `Invalid action: ${action}. Allowed actions: start, stop, restart, reload, status`
      });
    }
    
    let result = '';
    let status: 'running' | 'stopped' | 'failed' | 'unknown' = 'unknown';
    
    if (isProd) {
      try {
        switch (action) {
          case 'start':
            result = await serviceManager.start('httpd');
            // Check actual status after start attempt
            const startState = await serviceManager.getServiceState('httpd');
            status = startState === 'active' ? 'running' : 'failed';
            break;
          case 'stop':
            result = await serviceManager.stop('httpd');
            // Check actual status after stop attempt
            const stopState = await serviceManager.getServiceState('httpd');
            status = stopState === 'inactive' ? 'stopped' : 'failed';
            break;
          case 'restart':
          case 'reload':
            result = await serviceManager.restart('httpd');
            // Check actual status after restart attempt
            const restartState = await serviceManager.getServiceState('httpd');
            status = restartState === 'active' ? 'running' : 'failed';
            break;
          case 'status':
            const serviceState = await serviceManager.getServiceState('httpd');
            switch (serviceState) {
              case 'active':
                status = 'running';
                break;
              case 'inactive':
                status = 'stopped';
                break;
              case 'failed':
              case 'not-found':
                status = 'failed';
                break;
              default:
                status = 'unknown';
            }
            result = await serviceManager.getDetailedStatus('httpd');
            break;
        }
      } catch (error) {
        status = 'failed';
        result = (error as Error).message;
      }
    } else {
      result = `Development mode: ${action} action simulated`;
      status = action === 'stop' ? 'stopped' : 'running';
    }
    
    const response: HttpServiceResponse = {
      service: 'httpd',
      status,
      message: result || `Service ${action} completed`
    };
    
    res.status(200).json({
      success: true,
      data: response,
      message: `HTTP service ${action} completed successfully`
    });
    
  } catch (error) {
    logger.error(`Error performing HTTP service action:`, error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to control service'
    });
  }
}; 