import type { Response } from 'express';
import type { AuthRequest } from '../middlewares/authMiddleware';
import { httpConfigSchema, transformHttpFormToApi, transformHttpApiToForm, type HttpConfigFormValues } from '@server-manager/shared/validators';
import type { HttpConfiguration, HttpVirtualHost, HttpGlobalConfig, HttpServiceResponse, HttpDirective, HttpLogConfig, HttpDirectoryConfig } from '@server-manager/shared';
import { ZodError } from 'zod';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { existsSync } from 'fs';
import crypto from 'crypto';
import fs from 'fs';
import logger from '../lib/logger.js';
import { ServiceManager } from '../lib/ServiceManager.js';

const execAsync = promisify(exec);
const serviceManager = new ServiceManager();

// --- BEGIN Configuration ---
// Determine paths based on environment
const isProd = process.env.NODE_ENV === 'production';

// Directories where configuration files will be stored
const HTTPD_CONF_DIR = isProd ? '/etc/httpd/conf' : './test/http/config';
const HTTPD_VHOST_DIR = isProd ? '/etc/httpd/conf.d' : './test/http/vhost';
const HTTPD_CONF_PATH = isProd ? '/etc/httpd/conf/httpd.conf' : './test/http/config/httpd.conf';
const HTTPD_BACKUP_DIR = isProd ? '/etc/httpd/conf/backups' : './test/http/backups';

// Default configuration values based on standard Apache httpd.conf
const DEFAULT_HTTPD_CONFIG = {
  serverRoot: '/etc/httpd',
  serverAdmin: 'root@localhost',
  listen: [{ port: 80 }],
  user: 'apache',
  group: 'apache',
  errorLog: 'logs/error_log',
  logLevel: 'warn',
  enableSendfile: true,
  addDefaultCharset: 'UTF-8'
};
// --- END Configuration ---

/**
 * Ensure directory exists, create if not
 */
const ensureDirectoryExists = async (dir: string): Promise<void> => {
  if (!existsSync(dir)) {
    try {
      logger.info(`Creating directory: ${dir}`);
      await mkdir(dir, { recursive: true });
      logger.info(`Directory created: ${dir}`);
    } catch (error) {
      logger.error(`Error creating directory ${dir}:`, error);
      throw new Error(`Failed to create directory ${dir}: ${(error as Error).message}`);
    }
  }
};

/**
 * Check if we have write permission for a file
 */
const checkWritePermission = async (filePath: string): Promise<boolean> => {
  try {
    // Try to create the directory if it doesn't exist
    const dir = path.dirname(filePath);
    await ensureDirectoryExists(dir);
    
    // Try to write a test file
    const testFile = path.join(dir, '.test-write-permission');
    await writeFile(testFile, 'test');
    await fs.promises.unlink(testFile);
    return true;
  } catch (error) {
    logger.error(`No write permission for ${filePath}:`, error);
    return false;
  }
};

/**
 * Write file with backup functionality
 */
const writeFileWithBackup = async (
  filePath: string, 
  content: string, 
  options?: {
    writeJsonVersion?: boolean;
    jsonContent?: string;
    jsonGenerator?: () => string;
  }
): Promise<void> => {
  try {
    const dir = path.dirname(filePath);
    await ensureDirectoryExists(dir);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);

    // Create backup if file exists
    if (existsSync(filePath)) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(HTTPD_BACKUP_DIR, `${path.basename(filePath)}.${timestamp}.backup`);
      
      try {
        const existingContent = await readFile(filePath, 'utf8');
        await writeFile(backupPath, existingContent);
        logger.info(`Backup created: ${backupPath}`);
      } catch (error) {
        logger.error(`Failed to create backup for ${filePath}:`, error);
        throw new Error(`Failed to create backup: ${(error as Error).message}`);
      }
    }

    // Write new content
    await writeFile(filePath, content);
    logger.info(`Successfully wrote ${filePath}`);

    // Write JSON version if requested
    if (options?.writeJsonVersion) {
      const jsonPath = `${filePath}.json`;
      const jsonContent = options.jsonContent || (options.jsonGenerator ? options.jsonGenerator() : '{}');
      await writeFile(jsonPath, jsonContent);
      logger.info(`Successfully wrote JSON metadata: ${jsonPath}`);
    }
  } catch (error) {
    logger.error(`Error writing file ${filePath}:`, error);
    throw new Error(`Failed to write file: ${(error as Error).message}`);
  }
};

/**
 * Generate httpd.conf content based on standard Apache configuration
 */
export const generateHttpdConf = (config: HttpConfiguration): string => {
  const { globalConfig } = config;
  
  let conf = `# This is the main Apache HTTP server configuration file.
# Generated by Server Manager
# See <URL:http://httpd.apache.org/docs/2.4/> for detailed information.

ServerRoot "${globalConfig.serverRoot || DEFAULT_HTTPD_CONFIG.serverRoot}"

# Listen: Allows you to bind Apache to specific IP addresses and/or ports
`;

  // Listen directives
  globalConfig.listen.forEach((listen: { port: number; address?: string; ssl?: boolean }) => {
    if (listen.ssl) {
      conf += `Listen ${listen.address || '*'}:${listen.port} ssl\n`;
    } else {
      conf += `Listen ${listen.port}\n`;
    }
  });

  conf += `
# Dynamic Shared Object (DSO) Support
# Load config files in the conf.modules.d directory
Include conf.modules.d/*.conf

# User/Group: The name (or #number) of the user/group to run httpd as
User ${globalConfig.user || DEFAULT_HTTPD_CONFIG.user}
Group ${globalConfig.group || DEFAULT_HTTPD_CONFIG.group}

# ServerAdmin: Your address, where problems with the server should be e-mailed
ServerAdmin ${globalConfig.serverAdmin || DEFAULT_HTTPD_CONFIG.serverAdmin}
`;

  // Add ServerName if specified
  if (globalConfig.serverName) {
    conf += `\n# ServerName gives the name and port that the server uses to identify itself\nServerName ${globalConfig.serverName}\n`;
  }

  conf += `
# Deny access to the entirety of your server's filesystem
<Directory />
    AllowOverride none
    Require all denied
</Directory>

# DocumentRoot: The directory out of which you will serve your documents
DocumentRoot "/var/www/html"

# Relax access to content within /var/www
<Directory "/var/www">
    AllowOverride None
    # Allow open access:
    Require all granted
</Directory>

# Further relax access to the default document root:
<Directory "/var/www/html">
    # Possible values for the Options directive are "None", "All",
    # or any combination of:
    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
    Options Indexes FollowSymLinks

    # AllowOverride controls what directives may be placed in .htaccess files
    AllowOverride None

    # Controls who can get stuff from this server
    Require all granted
</Directory>

# DirectoryIndex: sets the file that Apache will serve if a directory is requested
<IfModule dir_module>
    DirectoryIndex index.html
</IfModule>

# Prevent .htaccess and .htpasswd files from being viewed by Web clients
<Files ".ht*">
    Require all denied
</Files>

# ErrorLog: The location of the error log file
ErrorLog "${globalConfig.errorLog || DEFAULT_HTTPD_CONFIG.errorLog}"

# LogLevel: Control the number of messages logged to the error_log
LogLevel ${globalConfig.logLevel || DEFAULT_HTTPD_CONFIG.logLevel}

<IfModule log_config_module>
    # Define some format nicknames for use with a CustomLog directive
    LogFormat "%h %l %u %t \\"%r\\" %>s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\"" combined
    LogFormat "%h %l %u %t \\"%r\\" %>s %b" common

    <IfModule logio_module>
      # You need to enable mod_logio.c to use %I and %O
      LogFormat "%h %l %u %t \\"%r\\" %>s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\" %I %O" combinedio
    </IfModule>

    # The location and format of the access logfile (Combined Logfile Format)
    CustomLog "logs/access_log" combined
</IfModule>

<IfModule alias_module>
    # ScriptAlias: This controls which directories contain server scripts
    ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"
</IfModule>

# "/var/www/cgi-bin" should be changed to whatever your ScriptAliased CGI directory exists
<Directory "/var/www/cgi-bin">
    AllowOverride None
    Options None
    Require all granted
</Directory>

<IfModule mime_module>
    # TypesConfig points to the file containing the list of mappings from
    # filename extension to MIME-type
    TypesConfig /etc/mime.types

    # AddType allows you to add to or override the MIME configuration
    AddType application/x-compress .Z
    AddType application/x-gzip .gz .tgz

    # For server-side includes (SSI)
    AddType text/html .shtml
    AddOutputFilter INCLUDES .shtml
</IfModule>

# Specify a default charset for all content served
AddDefaultCharset ${globalConfig.addDefaultCharset || DEFAULT_HTTPD_CONFIG.addDefaultCharset}

<IfModule mime_magic_module>
    # The mod_mime_magic module allows the server to use various hints
    MIMEMagicFile conf/magic
</IfModule>

# EnableSendfile: On systems that support it, sendfile syscall may be used to deliver files
EnableSendfile ${globalConfig.enableSendfile !== false ? 'on' : 'off'}

# Supplemental configuration
# Load config files in the "/etc/httpd/conf.d" directory, if any
IncludeOptional conf.d/*.conf
`;

  // Custom global directives
  if (globalConfig.customDirectives && globalConfig.customDirectives.length > 0) {
    conf += '\n# Custom global directives\n';
    globalConfig.customDirectives.forEach((directive: HttpDirective) => {
      if (directive.comment) {
        conf += `# ${directive.comment}\n`;
      }
      conf += `${directive.name} ${directive.value}\n`;
    });
  }

  return conf;
};

/**
 * Generate virtual host configuration file
 */
const generateVirtualHostConf = (vhost: HttpVirtualHost): string => {
  const portSpec = vhost.ipAddress ? `${vhost.ipAddress}:${vhost.port}` : `*:${vhost.port}`;
  
  let conf = `# Virtual Host: ${vhost.serverName}
# Generated by HTTP Management System
# REQUIRES: Main httpd.conf with proper module loading
# This file depends on modules loaded in /etc/httpd/conf/httpd.conf

<VirtualHost ${portSpec}>
    ServerName ${vhost.serverName}
`;

  // Server aliases
  if (vhost.serverAlias && vhost.serverAlias.length > 0) {
    conf += `    ServerAlias ${vhost.serverAlias.join(' ')}\n`;
  }

  conf += `    DocumentRoot "${vhost.documentRoot}"\n`;

  // Directory index
  if (vhost.directoryIndex && vhost.directoryIndex.length > 0) {
    conf += `    DirectoryIndex ${vhost.directoryIndex.join(' ')}\n`;
  }

  // Logging
  if (vhost.errorLog) {
    conf += `    ErrorLog "${vhost.errorLog}"\n`;
  }
  
  if (vhost.customLog && vhost.customLog.length > 0) {
    vhost.customLog.forEach((log: HttpLogConfig) => {
      conf += `    CustomLog "${log.path}" ${log.format || 'combined'}\n`;
    });
  }

  if (vhost.logLevel) {
    conf += `    LogLevel ${vhost.logLevel}\n`;
  }

  // SSL Configuration
  if (vhost.ssl?.enabled) {
    conf += `\n    # SSL Configuration
    SSLEngine ${vhost.ssl.sslEngine ? 'on' : 'off'}
`;
    if (vhost.ssl.certificateFile) {
      conf += `    SSLCertificateFile "${vhost.ssl.certificateFile}"\n`;
    }
    if (vhost.ssl.certificateKeyFile) {
      conf += `    SSLCertificateKeyFile "${vhost.ssl.certificateKeyFile}"\n`;
    }
    if (vhost.ssl.certificateChainFile) {
      conf += `    SSLCertificateChainFile "${vhost.ssl.certificateChainFile}"\n`;
    }
    if (vhost.ssl.sslProtocol && vhost.ssl.sslProtocol.length > 0) {
      conf += `    SSLProtocol ${vhost.ssl.sslProtocol.join(' ')}\n`;
    }
    if (vhost.ssl.sslCipherSuite) {
      conf += `    SSLCipherSuite "${vhost.ssl.sslCipherSuite}"\n`;
    }
  }

  // Directory configurations
  if (vhost.directories && vhost.directories.length > 0) {
    vhost.directories.forEach((dir: HttpDirectoryConfig) => {
      conf += `\n    <Directory "${dir.path}">
`;
      if (dir.allowOverride) {
        conf += `        AllowOverride ${dir.allowOverride}\n`;
      }
      if (dir.options && dir.options.length > 0) {
        conf += `        Options ${dir.options.join(' ')}\n`;
      }
      if (dir.require && dir.require.length > 0) {
        dir.require.forEach((req: string) => {
          conf += `        Require ${req}\n`;
        });
      }
      if (dir.directoryIndex && dir.directoryIndex.length > 0) {
        conf += `        DirectoryIndex ${dir.directoryIndex.join(' ')}\n`;
      }
      if (dir.customDirectives && dir.customDirectives.length > 0) {
        dir.customDirectives.forEach((directive: HttpDirective) => {
          if (directive.comment) {
            conf += `        # ${directive.comment}\n`;
          }
          conf += `        ${directive.name} ${directive.value}\n`;
        });
      }
      conf += `    </Directory>\n`;
    });
  }

  // Redirects
  if (vhost.redirects && vhost.redirects.length > 0) {
    conf += '\n    # Redirects\n';
    vhost.redirects.forEach((redirect: { from: string; to: string; type: 'permanent' | 'temporary' | 'seeother' | 'gone' }) => {
      const redirectType = redirect.type === 'permanent' ? '301' : 
                          redirect.type === 'temporary' ? '302' : 
                          redirect.type === 'seeother' ? '303' : '410';
      conf += `    Redirect ${redirectType} ${redirect.from} ${redirect.to}\n`;
    });
  }

  // Rewrites
  if (vhost.rewrites && vhost.rewrites.length > 0) {
    conf += '\n    # Rewrites\n    RewriteEngine On\n';
    vhost.rewrites.forEach((rewrite: { pattern: string; substitution: string; flags?: string[] }) => {
      const flags = rewrite.flags && rewrite.flags.length > 0 ? ` [${rewrite.flags.join(',')}]` : '';
      conf += `    RewriteRule ${rewrite.pattern} ${rewrite.substitution}${flags}\n`;
    });
  }

  // Custom directives
  if (vhost.customDirectives && vhost.customDirectives.length > 0) {
    conf += '\n    # Custom directives\n';
    vhost.customDirectives.forEach((directive: HttpDirective) => {
      if (directive.comment) {
        conf += `    # ${directive.comment}\n`;
      }
      conf += `    ${directive.name} ${directive.value}\n`;
    });
  }

  conf += '</VirtualHost>\n';
  return conf;
};

/**
 * Validate Apache configuration syntax
 */
const validateHttpdConfiguration = async (): Promise<void> => {
  try {
    if (isProd) {
      const { stdout, stderr } = await execAsync('httpd -t');
      logger.info('Apache configuration validation passed:', stdout);
    } else {
      // In development, just check if config files exist and are readable
      if (existsSync(HTTPD_CONF_PATH)) {
        await readFile(HTTPD_CONF_PATH, 'utf8');
      }
    }
    logger.info('Apache configuration validation passed');
  } catch (error: any) {
    logger.error('Apache configuration validation failed:', error);
    
    // Provide specific help for common issues
    const errorMessage = error.message || error.stderr || error.stdout || String(error);
    let helpMessage = 'Configuration validation failed';
    
    if (errorMessage.includes('CustomLog') || errorMessage.includes('mod_log_config')) {
      helpMessage = 'mod_log_config module is not available. Install with: dnf install httpd';
    } else if (errorMessage.includes('mod_ssl')) {
      helpMessage = 'mod_ssl module is not available. Install with: dnf install mod_ssl';
    } else if (errorMessage.includes('Invalid command')) {
      helpMessage = 'Missing Apache module. Check that all required modules are installed.';
    }
    
    throw new Error(`${helpMessage}: ${errorMessage}`);
  }
};

/**
 * Reload Apache service
 */
const reloadHttpdService = async (): Promise<void> => {
  try {
    if (isProd) {
      await serviceManager.restart('httpd');
    } else {
      logger.info('Development mode: skipping actual service reload');
    }
    logger.info('Apache service reloaded successfully');
  } catch (error) {
    logger.error('Failed to reload Apache service:', error);
    throw new Error(`Failed to reload Apache service: ${(error as Error).message}`);
  }
};

/**
 * Get current HTTP configuration
 */
export const getCurrentHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    logger.debug(`Running in ${isProd ? 'PRODUCTION' : 'DEVELOPMENT'} mode`);
    logger.debug(`Using HTTPD_CONF_PATH: ${HTTPD_CONF_PATH}`);
    
    // Get the status of the httpd service
    let serviceRunning = false;
    if (isProd) {
      try {
        // First check if the service exists
        const serviceExists = await serviceManager.exists('httpd');
        if (serviceExists) {
          serviceRunning = await serviceManager.status('httpd');
          logger.info(`Apache service is ${serviceRunning ? 'running' : 'not running'}`);
        } else {
          logger.warn('Apache httpd service is not installed. Install with: sudo dnf install httpd');
        }
      } catch (error) {
        logger.info('Error checking Apache service status, assuming not running');
      }
    }
    
    // Path to the JSON configuration file
    const httpdConfJsonPath = `${HTTPD_CONF_PATH}.json`;
    
    // Try to read the JSON configuration file
    let configJson = null;
    
    try {
      const configData = await readFile(httpdConfJsonPath, 'utf8');
      configJson = JSON.parse(configData);
      logger.debug(`Successfully read httpd.conf.json from ${httpdConfJsonPath}`);
    } catch (error) {
      logger.info(`httpd.conf.json does not exist or is invalid at ${httpdConfJsonPath}`);
    }
    
    // If JSON configuration file doesn't exist, return a default configuration
    if (!configJson) {
      logger.info('No existing JSON configuration found, returning default configuration');
      const defaultConfig: HttpConfiguration = {
        serverStatus: serviceRunning,
        globalConfig: {
          serverRoot: DEFAULT_HTTPD_CONFIG.serverRoot,
          serverAdmin: DEFAULT_HTTPD_CONFIG.serverAdmin,
          listen: DEFAULT_HTTPD_CONFIG.listen,
          user: DEFAULT_HTTPD_CONFIG.user,
          group: DEFAULT_HTTPD_CONFIG.group,
          errorLog: DEFAULT_HTTPD_CONFIG.errorLog,
          logLevel: DEFAULT_HTTPD_CONFIG.logLevel,
          addDefaultCharset: DEFAULT_HTTPD_CONFIG.addDefaultCharset,
          enableSendfile: DEFAULT_HTTPD_CONFIG.enableSendfile
        },
        virtualHosts: []
      };
      
      return res.status(200).json({
        message: 'Default configuration returned - no existing configuration found',
        data: defaultConfig
      });
    }
    
    // Add service status to the configuration
    configJson.serverStatus = serviceRunning;
    
    logger.info('Successfully loaded current HTTP configuration from JSON file');
    res.status(200).json({ 
      message: 'Current HTTP configuration loaded successfully',
      data: configJson 
    });
  } catch (error) {
    logger.error('Error getting HTTP configuration:', error);
    res.status(500).json({ 
      message: error instanceof Error ? error.message : 'Failed to get HTTP configuration' 
    });
  }
};

/**
 * Update HTTP configuration
 */
export const updateHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    // Validate the request body
    const validatedFormData: HttpConfigFormValues = httpConfigSchema.parse(req.body);
    
    // Transform form data to API format
    const validatedConfig: HttpConfiguration = transformHttpFormToApi(validatedFormData);

    logger.info('Received HTTP Configuration:', { config: JSON.stringify(validatedConfig, null, 2) });
    logger.debug(`Running in ${isProd ? 'PRODUCTION' : 'DEVELOPMENT'} mode`);
    logger.debug(`Using HTTPD_CONF_PATH: ${HTTPD_CONF_PATH}`);
    logger.debug(`Using HTTPD_VHOST_DIR: ${HTTPD_VHOST_DIR}`);
    
    // In production, check permissions
    if (isProd) {
      const canWriteConf = await checkWritePermission(HTTPD_CONF_PATH);
      const canWriteVhost = await checkWritePermission(path.join(HTTPD_VHOST_DIR, 'test.conf'));
      
      if (!canWriteConf || !canWriteVhost) {
        return res.status(403).json({
          message: 'Insufficient permissions',
          details: 'The server needs write access to HTTP configuration directories. Please run with sudo or check permissions.',
          paths: {
            canWriteConf,
            canWriteVhost,
            httpdConfPath: HTTPD_CONF_PATH,
            httpdVhostDir: HTTPD_VHOST_DIR
          }
        });
      }
    }
    
    // Ensure required directories exist
    await ensureDirectoryExists(HTTPD_CONF_DIR);
    await ensureDirectoryExists(HTTPD_VHOST_DIR);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);
    
    // IMPORTANT: Generate and write main httpd.conf FIRST
    // This ensures all required modules are loaded before virtual hosts
    logger.info('Generating main httpd.conf with required modules...');
    const httpdConf = generateHttpdConf(validatedConfig);
    await writeFileWithBackup(HTTPD_CONF_PATH, httpdConf, {
      writeJsonVersion: true,
      jsonGenerator: () => JSON.stringify(validatedConfig, null, 2)
    });
    logger.info(`Main httpd.conf written to ${HTTPD_CONF_PATH}`);
    
    // Remove existing virtual host files (cleanup)
    try {
      const vhostFiles = await fs.promises.readdir(HTTPD_VHOST_DIR);
      for (const file of vhostFiles) {
        if (file.endsWith('.conf') && !file.startsWith('.')) {
          await fs.promises.unlink(path.join(HTTPD_VHOST_DIR, file));
        }
      }
    } catch (error) {
      logger.warn('Could not clean up existing virtual host files:', error);
    }
    
    // Generate and write virtual host files
    for (const vhost of validatedConfig.virtualHosts) {
      if (vhost.enabled) {
        const vhostConf = generateVirtualHostConf(vhost);
        const vhostFilePath = path.join(HTTPD_VHOST_DIR, `${vhost.serverName}.conf`);
        
        logger.info(`Generating virtual host file for ${vhost.serverName} at ${vhostFilePath}`);
        await writeFileWithBackup(vhostFilePath, vhostConf, {
          writeJsonVersion: true,
          jsonGenerator: () => JSON.stringify(vhost, null, 2)
        });
      }
    }
    
    // Validate Apache configuration
    try {
      await validateHttpdConfiguration();
    } catch (error) {
      return res.status(400).json({
        message: 'HTTP configuration validation failed',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
    
    // Only reload if the HTTP server is enabled
    if (validatedConfig.serverStatus) {
      try {
        await reloadHttpdService();
      } catch (error) {
        return res.status(500).json({
          message: 'Failed to reload HTTP server',
          error: error instanceof Error ? error.message : 'Unknown error',
          note: 'Configuration files were updated but service reload failed'
        });
      }
    } else {
      logger.info('HTTP server is disabled, skipping reload');
    }
    
    res.status(200).json({ 
      message: 'HTTP configuration updated successfully',
      data: validatedConfig 
    });

  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ 
        message: 'Validation Error', 
        errors: error.errors 
      });
    }
    
    logger.error('Error updating HTTP configuration:', error);
    res.status(500).json({ 
      message: error instanceof Error ? error.message : 'Failed to update HTTP configuration' 
    });
  }
};

/**
 * Validate HTTP configuration without applying changes
 */
export const validateHttpConfiguration = async (req: AuthRequest, res: Response) => {
  try {
    // Validate the request body format
    const validatedFormData: HttpConfigFormValues = httpConfigSchema.parse(req.body);
    const validatedConfig: HttpConfiguration = transformHttpFormToApi(validatedFormData);
    
    // Generate configuration content for validation
    const httpdConf = generateHttpdConf(validatedConfig);
    
    // Write to temporary file for validation
    const tempConfPath = path.join(HTTPD_BACKUP_DIR, `temp-httpd-${Date.now()}.conf`);
    await ensureDirectoryExists(HTTPD_BACKUP_DIR);
    await writeFile(tempConfPath, httpdConf);
    
    try {
      if (isProd) {
        // Use Apache's configuration test with temporary file
        await execAsync(`httpd -t -f ${tempConfPath}`);
      }
      
      // Clean up temporary file
      await fs.promises.unlink(tempConfPath);
      
      res.status(200).json({
        message: 'HTTP configuration validation passed',
        valid: true
      });
    } catch (error) {
      // Clean up temporary file on error
      try {
        await fs.promises.unlink(tempConfPath);
      } catch {}
      
      throw error;
    }
    
  } catch (error) {
    if (error instanceof ZodError) {
      return res.status(400).json({ 
        message: 'Validation Error', 
        errors: error.errors,
        valid: false
      });
    }
    
    logger.error('HTTP configuration validation failed:', error);
    res.status(400).json({ 
      message: 'Configuration validation failed',
      error: error instanceof Error ? error.message : 'Unknown error',
      valid: false
    });
  }
};

/**
 * Get HTTP service status
 */
export const getHttpServiceStatus = async (req: AuthRequest, res: Response) => {
  try {
    let status: 'running' | 'stopped' | 'failed' | 'unknown' = 'unknown';
    let message = 'Service status unknown';
    
    if (isProd) {
      try {
        // Get the detailed service state
        const serviceState = await serviceManager.getServiceState('httpd');
        
        switch (serviceState) {
          case 'active':
            status = 'running';
            message = 'Apache service is running';
            break;
          case 'inactive':
            status = 'stopped';
            message = 'Apache service is stopped';
            break;
          case 'failed':
            status = 'failed';
            message = 'Apache service has failed. Check configuration and restart service.';
            break;
          case 'not-found':
            status = 'failed';
            message = 'Apache httpd service is not installed. Install with: sudo dnf install httpd';
            break;
          default:
            status = 'unknown';
            message = `Apache service state: ${serviceState}`;
        }
      } catch (error) {
        status = 'failed';
        message = `Failed to check service status: ${(error as Error).message}`;
      }
    } else {
      status = 'stopped';
      message = 'Development mode - service not managed';
    }
    
    const response: HttpServiceResponse = {
      service: 'httpd',
      status,
      message
    };
    
    res.status(200).json({
      success: true,
      data: response
    });
    
  } catch (error) {
    logger.error('Error getting HTTP service status:', error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to get service status'
    });
  }
};

/**
 * Control HTTP service (start, stop, restart, reload)
 */
export const controlHttpService = async (req: AuthRequest, res: Response) => {
  try {
    const { action } = req.params;
    
    if (!['start', 'stop', 'restart', 'reload', 'status'].includes(action)) {
      return res.status(400).json({
        success: false,
        message: `Invalid action: ${action}. Allowed actions: start, stop, restart, reload, status`
      });
    }
    
    let result = '';
    let status: 'running' | 'stopped' | 'failed' | 'unknown' = 'unknown';
    
    if (isProd) {
      try {
        switch (action) {
          case 'start':
            result = await serviceManager.start('httpd');
            // Check actual status after start attempt
            const startState = await serviceManager.getServiceState('httpd');
            status = startState === 'active' ? 'running' : 'failed';
            break;
          case 'stop':
            result = await serviceManager.stop('httpd');
            // Check actual status after stop attempt
            const stopState = await serviceManager.getServiceState('httpd');
            status = stopState === 'inactive' ? 'stopped' : 'failed';
            break;
          case 'restart':
          case 'reload':
            result = await serviceManager.restart('httpd');
            // Check actual status after restart attempt
            const restartState = await serviceManager.getServiceState('httpd');
            status = restartState === 'active' ? 'running' : 'failed';
            break;
          case 'status':
            const serviceState = await serviceManager.getServiceState('httpd');
            switch (serviceState) {
              case 'active':
                status = 'running';
                break;
              case 'inactive':
                status = 'stopped';
                break;
              case 'failed':
              case 'not-found':
                status = 'failed';
                break;
              default:
                status = 'unknown';
            }
            result = await serviceManager.getDetailedStatus('httpd');
            break;
        }
      } catch (error) {
        status = 'failed';
        result = (error as Error).message;
      }
    } else {
      result = `Development mode: ${action} action simulated`;
      status = action === 'stop' ? 'stopped' : 'running';
    }
    
    const response: HttpServiceResponse = {
      service: 'httpd',
      status,
      message: result || `Service ${action} completed`
    };
    
    res.status(200).json({
      success: true,
      data: response,
      message: `HTTP service ${action} completed successfully`
    });
    
  } catch (error) {
    logger.error(`Error performing HTTP service action:`, error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : 'Failed to control service'
    });
  }
}; 